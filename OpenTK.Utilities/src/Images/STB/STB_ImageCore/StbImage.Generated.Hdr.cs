// Generated by Sichem at 12/24/2021 8:28:15 PM

using Hebron.Runtime;

namespace OpenTK.Utilities.Images
{
	unsafe partial class ImageCore
	{
		public static int HdrTest(Context s)
		{
			var r = HdrTestCore(s, "#?RADIANCE\n");
			Rewind(s);
			if (r == 0)
			{
				r = HdrTestCore(s, "#?RGBE\n");
				Rewind(s);
			}

			return r;
		}

		public static float* HdrLoad(Context s, int* x, int* y, int* comp, int req_comp,
			ResultInfo* ri)
		{
			var buffer = stackalloc sbyte[1024];
			sbyte* token;
			var valid = 0;
			var width = 0;
			var height = 0;
			byte* scanline;
			float* hdr_data;
			var len = 0;
			byte count = 0;
			byte value = 0;
			var i = 0;
			var j = 0;
			var k = 0;
			var c1 = 0;
			var c2 = 0;
			var z = 0;
			sbyte* headerToken;
			headerToken = HdrGettoken(s, buffer);
			if (CRuntime.strcmp(headerToken, "#?RADIANCE") != 0 && CRuntime.strcmp(headerToken, "#?RGBE") != 0)
				return (float*)(ulong)(Err("not HDR") != 0 ? 0 : 0);
			for (; ; )
			{
				token = HdrGettoken(s, buffer);
				if (token[0] == 0)
					break;
				if (CRuntime.strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0)
					valid = 1;
			}

			if (valid == 0)
				return (float*)(ulong)(Err("unsupported format") != 0 ? 0 : 0);
			token = HdrGettoken(s, buffer);
			if (CRuntime.strncmp(token, "-Y ", 3) != 0)
				return (float*)(ulong)(Err("unsupported data layout") != 0 ? 0 : 0);
			token += 3;
			height = (int)CRuntime.strtol(token, &token, 10);
			while (*token == 32)
				++token;
			if (CRuntime.strncmp(token, "+X ", 3) != 0)
				return (float*)(ulong)(Err("unsupported data layout") != 0 ? 0 : 0);
			token += 3;
			width = (int)CRuntime.strtol(token, null, 10);
			if (height > 1 << 24)
				return (float*)(ulong)(Err("too large") != 0 ? 0 : 0);
			if (width > 1 << 24)
				return (float*)(ulong)(Err("too large") != 0 ? 0 : 0);
			*x = width;
			*y = height;
			if (comp != null)
				*comp = 3;
			if (req_comp == 0)
				req_comp = 3;
			if (Mad4sizesValid(width, height, req_comp, sizeof(float), 0) == 0)
				return (float*)(ulong)(Err("too large") != 0 ? 0 : 0);
			hdr_data = (float*)MallocMad4(width, height, req_comp, sizeof(float), 0);
			if (hdr_data == null)
				return (float*)(ulong)(Err("outofmem") != 0 ? 0 : 0);
			main_decode_loop:
			var enterMainDecode = false;
			if (enterMainDecode)
			{
				for (; j < height; ++j)
					for (; i < width; ++i)
					{
						var rgbe = stackalloc byte[4];
						Getn(s, rgbe, 4);
						HdrConvert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
					}

				goto finish;
			}

			if (width < 8 || width >= 32768)
			{
				i = j = 0;
				enterMainDecode = true;
				goto main_decode_loop;
			}

			scanline = null;
			for (j = 0; j < height; ++j)
			{
				c1 = Get8(s);
				c2 = Get8(s);
				len = Get8(s);
				if (c1 != 2 || c2 != 2 || (len & 0x80) != 0)
				{
					var rgbe = stackalloc byte[4];
					rgbe[0] = (byte)c1;
					rgbe[1] = (byte)c2;
					rgbe[2] = (byte)len;
					rgbe[3] = Get8(s);
					HdrConvert(hdr_data, rgbe, req_comp);
					i = 1;
					j = 0;
					CRuntime.free(scanline);
					goto main_decode_loop;
				}

				len <<= 8;
				len |= Get8(s);
				if (len != width)
				{
					CRuntime.free(hdr_data);
					CRuntime.free(scanline);
					return (float*)(ulong)(Err("invalid decoded scanline length") != 0 ? 0 : 0);
				}

				if (scanline == null)
				{
					scanline = (byte*)MallocMad2(width, 4, 0);
					if (scanline == null)
					{
						CRuntime.free(hdr_data);
						return (float*)(ulong)(Err("outofmem") != 0 ? 0 : 0);
					}
				}

				for (k = 0; k < 4; ++k)
				{
					var nleft = 0;
					i = 0;
					while ((nleft = width - i) > 0)
					{
						count = Get8(s);
						if (count > 128)
						{
							value = Get8(s);
							count -= 128;
							if (count > nleft)
							{
								CRuntime.free(hdr_data);
								CRuntime.free(scanline);
								return (float*)(ulong)(Err("corrupt") != 0 ? 0 : 0);
							}

							for (z = 0; z < count; ++z)
								scanline[i++ * 4 + k] = value;
						}
						else
						{
							if (count > nleft)
							{
								CRuntime.free(hdr_data);
								CRuntime.free(scanline);
								return (float*)(ulong)(Err("corrupt") != 0 ? 0 : 0);
							}

							for (z = 0; z < count; ++z)
								scanline[i++ * 4 + k] = Get8(s);
						}
					}
				}

				for (i = 0; i < width; ++i)
					HdrConvert(hdr_data + (j * width + i) * req_comp, scanline + i * 4, req_comp);
			}

			if (scanline != null)
				CRuntime.free(scanline);
			finish:
			return hdr_data;
		}

		public static int HdrInfo(Context s, int* x, int* y, int* comp)
		{
			var buffer = stackalloc sbyte[1024];
			sbyte* token;
			var valid = 0;
			var dummy = 0;
			if (x == null)
				x = &dummy;
			if (y == null)
				y = &dummy;
			if (comp == null)
				comp = &dummy;
			if (HdrTest(s) == 0)
			{
				Rewind(s);
				return 0;
			}

			for (; ; )
			{
				token = HdrGettoken(s, buffer);
				if (token[0] == 0)
					break;
				if (CRuntime.strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0)
					valid = 1;
			}

			if (valid == 0)
			{
				Rewind(s);
				return 0;
			}

			token = HdrGettoken(s, buffer);
			if (CRuntime.strncmp(token, "-Y ", 3) != 0)
			{
				Rewind(s);
				return 0;
			}

			token += 3;
			*y = (int)CRuntime.strtol(token, &token, 10);
			while (*token == 32)
				++token;
			if (CRuntime.strncmp(token, "+X ", 3) != 0)
			{
				Rewind(s);
				return 0;
			}

			token += 3;
			*x = (int)CRuntime.strtol(token, null, 10);
			*comp = 3;
			return 1;
		}

		public static byte* HdrToLdr(float* data, int x, int y, int comp)
		{
			var i = 0;
			var k = 0;
			var n = 0;
			byte* output;
			if (data == null)
				return null;
			output = (byte*)MallocMad3(x, y, comp, 0);
			if (output == null)
			{
				CRuntime.free(data);
				return (byte*)(ulong)(Err("outofmem") != 0 ? 0 : 0);
			}

			if ((comp & 1) != 0)
				n = comp;
			else
				n = comp - 1;
			for (i = 0; i < x * y; ++i)
			{
				for (k = 0; k < n; ++k)
				{
					var z = (float)CRuntime.pow(data[i * comp + k] * H2lScaleI, H2lGammaI) * 255 +
							0.5f;
					if (z < 0)
						z = 0;
					if (z > 255)
						z = 255;
					output[i * comp + k] = (byte)(int)z;
				}

				if (k < comp)
				{
					var z = data[i * comp + k] * 255 + 0.5f;
					if (z < 0)
						z = 0;
					if (z > 255)
						z = 255;
					output[i * comp + k] = (byte)(int)z;
				}
			}

			CRuntime.free(data);
			return output;
		}

		public static int HdrTestCore(Context s, string signature)
		{
			var i = 0;
			for (i = 0; i < signature.Length; ++i)
				if (Get8(s) != signature[i])
					return 0;
			Rewind(s);
			return 1;
		}

		public static sbyte* HdrGettoken(Context z, sbyte* buffer)
		{
			var len = 0;
			sbyte c = 0;
			c = (sbyte)Get8(z);
			while (AtEof(z) == 0 && c != 10)
			{
				buffer[len++] = c;
				if (len == 1024 - 1)
				{
					while (AtEof(z) == 0 && Get8(z) != 10)
					{
					}

					break;
				}

				c = (sbyte)Get8(z);
			}

			buffer[len] = 0;
			return buffer;
		}

		public static void HdrConvert(float* output, byte* input, int req_comp)
		{
			if (input[3] != 0)
			{
				float f1 = 0;
				f1 = (float)CRuntime.ldexp(1.0f, input[3] - (128 + 8));
				if (req_comp <= 2)
				{
					output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
				}
				else
				{
					output[0] = input[0] * f1;
					output[1] = input[1] * f1;
					output[2] = input[2] * f1;
				}

				if (req_comp == 2)
					output[1] = 1;
				if (req_comp == 4)
					output[3] = 1;
			}
			else
			{
				switch (req_comp)
				{
					case 4:
					case 3:
						if (req_comp == 4)
							output[3] = 1;
						output[0] = output[1] = output[2] = 0;
						break;
					case 2:
					case 1:
						if (req_comp == 2)
							output[1] = 1;
						output[0] = 0;
						break;
				}
			}
		}
	}
}
