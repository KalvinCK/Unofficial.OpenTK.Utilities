// Generated by Sichem at 12/24/2021 8:28:15 PM

using System.Runtime.InteropServices;
using Hebron.Runtime;

namespace OpenTK.Utilities.Images
{
	unsafe partial class ImageCore
	{
		public static int BmpTest(Context s)
		{
			var r = BmpTestRaw(s);
			Rewind(s);
			return r;
		}

		public static void* BmpLoad(Context s, int* x, int* y, int* comp, int req_comp,
			ResultInfo* ri)
		{
			byte* _out_;
			uint mr = 0;
			uint mg = 0;
			uint mb = 0;
			uint ma = 0;
			uint all_a = 0;
			var pal = Utility.CreateArray<byte>(256, 4);
			var psize = 0;
			var i = 0;
			var j = 0;
			var width = 0;
			var flip_vertically = 0;
			var pad = 0;
			var target = 0;
			var info = new BmpData();
			info.all_a = 255;
			if (BmpParseHeader(s, &info) == null)
				return null;
			flip_vertically = (int)s.img_y > 0 ? 1 : 0;
			s.img_y = (uint)CRuntime.abs((int)s.img_y);
			if (s.img_y > 1 << 24)
				return (byte*)(ulong)(Err("too large") != 0 ? 0 : 0);
			if (s.img_x > 1 << 24)
				return (byte*)(ulong)(Err("too large") != 0 ? 0 : 0);
			mr = info.mr;
			mg = info.mg;
			mb = info.mb;
			ma = info.ma;
			all_a = info.all_a;
			if (info.hsz == 12)
			{
				if (info.bpp < 24)
					psize = (info.offset - info.extra_read - 24) / 3;
			}
			else
			{
				if (info.bpp < 16)
					psize = (info.offset - info.extra_read - info.hsz) >> 2;
			}

			if (info.bpp == 24 && ma == 0xff000000)
				s.img_n = 3;
			else
				s.img_n = ma != 0 ? 4 : 3;
			if (req_comp != 0 && req_comp >= 3)
				target = req_comp;
			else
				target = s.img_n;
			if (Mad3sizesValid(target, (int)s.img_x, (int)s.img_y, 0) == 0)
				return (byte*)(ulong)(Err("too large") != 0 ? 0 : 0);
			_out_ = (byte*)MallocMad3(target, (int)s.img_x, (int)s.img_y, 0);
			if (_out_ == null)
				return (byte*)(ulong)(Err("outofmem") != 0 ? 0 : 0);
			if (info.bpp < 16)
			{
				var z = 0;
				if (psize == 0 || psize > 256)
				{
					CRuntime.free(_out_);
					return (byte*)(ulong)(Err("invalid") != 0 ? 0 : 0);
				}

				for (i = 0; i < psize; ++i)
				{
					pal[i][2] = Get8(s);
					pal[i][1] = Get8(s);
					pal[i][0] = Get8(s);
					if (info.hsz != 12)
						Get8(s);
					pal[i][3] = 255;
				}

				Skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
				if (info.bpp == 1)
				{
					width = (int)((s.img_x + 7) >> 3);
				}
				else if (info.bpp == 4)
				{
					width = (int)((s.img_x + 1) >> 1);
				}
				else if (info.bpp == 8)
				{
					width = (int)s.img_x;
				}
				else
				{
					CRuntime.free(_out_);
					return (byte*)(ulong)(Err("bad bpp") != 0 ? 0 : 0);
				}

				pad = -width & 3;
				if (info.bpp == 1)
					for (j = 0; j < (int)s.img_y; ++j)
					{
						var bit_offset = 7;
						int v = Get8(s);
						for (i = 0; i < (int)s.img_x; ++i)
						{
							var color = (v >> bit_offset) & 0x1;
							_out_[z++] = pal[color][0];
							_out_[z++] = pal[color][1];
							_out_[z++] = pal[color][2];
							if (target == 4)
								_out_[z++] = 255;
							if (i + 1 == (int)s.img_x)
								break;
							if (--bit_offset < 0)
							{
								bit_offset = 7;
								v = Get8(s);
							}
						}

						Skip(s, pad);
					}
				else
					for (j = 0; j < (int)s.img_y; ++j)
					{
						for (i = 0; i < (int)s.img_x; i += 2)
						{
							int v = Get8(s);
							var v2 = 0;
							if (info.bpp == 4)
							{
								v2 = v & 15;
								v >>= 4;
							}

							_out_[z++] = pal[v][0];
							_out_[z++] = pal[v][1];
							_out_[z++] = pal[v][2];
							if (target == 4)
								_out_[z++] = 255;
							if (i + 1 == (int)s.img_x)
								break;
							v = info.bpp == 8 ? Get8(s) : v2;
							_out_[z++] = pal[v][0];
							_out_[z++] = pal[v][1];
							_out_[z++] = pal[v][2];
							if (target == 4)
								_out_[z++] = 255;
						}

						Skip(s, pad);
					}
			}
			else
			{
				var rshift = 0;
				var gshift = 0;
				var bshift = 0;
				var ashift = 0;
				var rcount = 0;
				var gcount = 0;
				var bcount = 0;
				var acount = 0;
				var z = 0;
				var easy = 0;
				Skip(s, info.offset - info.extra_read - info.hsz);
				if (info.bpp == 24)
					width = (int)(3 * s.img_x);
				else if (info.bpp == 16)
					width = (int)(2 * s.img_x);
				else
					width = 0;
				pad = -width & 3;
				if (info.bpp == 24)
					easy = 1;
				else if (info.bpp == 32)
					if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
						easy = 2;
				if (easy == 0)
				{
					if (mr == 0 || mg == 0 || mb == 0)
					{
						CRuntime.free(_out_);
						return (byte*)(ulong)(Err("bad masks") != 0 ? 0 : 0);
					}

					rshift = HighBit(mr) - 7;
					rcount = Bitcount(mr);
					gshift = HighBit(mg) - 7;
					gcount = Bitcount(mg);
					bshift = HighBit(mb) - 7;
					bcount = Bitcount(mb);
					ashift = HighBit(ma) - 7;
					acount = Bitcount(ma);
					if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8)
					{
						CRuntime.free(_out_);
						return (byte*)(ulong)(Err("bad masks") != 0 ? 0 : 0);
					}
				}

				for (j = 0; j < (int)s.img_y; ++j)
				{
					if (easy != 0)
					{
						for (i = 0; i < (int)s.img_x; ++i)
						{
							byte a = 0;
							_out_[z + 2] = Get8(s);
							_out_[z + 1] = Get8(s);
							_out_[z + 0] = Get8(s);
							z += 3;
							a = (byte)(easy == 2 ? Get8(s) : 255);
							all_a |= a;
							if (target == 4)
								_out_[z++] = a;
						}
					}
					else
					{
						var bpp = info.bpp;
						for (i = 0; i < (int)s.img_x; ++i)
						{
							var v = bpp == 16 ? (uint)Get16le(s) : Get32le(s);
							uint a = 0;
							_out_[z++] = (byte)(Shiftsigned(v & mr, rshift, rcount) & 255);
							_out_[z++] = (byte)(Shiftsigned(v & mg, gshift, gcount) & 255);
							_out_[z++] = (byte)(Shiftsigned(v & mb, bshift, bcount) & 255);
							a = (uint)(ma != 0 ? Shiftsigned(v & ma, ashift, acount) : 255);
							all_a |= a;
							if (target == 4)
								_out_[z++] = (byte)(a & 255);
						}
					}

					Skip(s, pad);
				}
			}

			if (target == 4 && all_a == 0)
				for (i = (int)(4 * s.img_x * s.img_y - 1); i >= 0; i -= 4)
					_out_[i] = 255;
			if (flip_vertically != 0)
			{
				byte t = 0;
				for (j = 0; j < (int)s.img_y >> 1; ++j)
				{
					var p1 = _out_ + j * s.img_x * target;
					var p2 = _out_ + (s.img_y - 1 - j) * s.img_x * target;
					for (i = 0; i < (int)s.img_x * target; ++i)
					{
						t = p1[i];
						p1[i] = p2[i];
						p2[i] = t;
					}
				}
			}

			if (req_comp != 0 && req_comp != target)
			{
				_out_ = ConvertFormat(_out_, target, req_comp, s.img_x, s.img_y);
				if (_out_ == null)
					return _out_;
			}

			*x = (int)s.img_x;
			*y = (int)s.img_y;
			if (comp != null)
				*comp = s.img_n;
			return _out_;
		}

		public static int BmpInfo(Context s, int* x, int* y, int* comp)
		{
			void* p;
			var info = new BmpData();
			info.all_a = 255;
			p = BmpParseHeader(s, &info);
			if (p == null)
			{
				Rewind(s);
				return 0;
			}

			if (x != null)
				*x = (int)s.img_x;
			if (y != null)
				*y = (int)s.img_y;
			if (comp != null)
			{
				if (info.bpp == 24 && info.ma == 0xff000000)
					*comp = 3;
				else
					*comp = info.ma != 0 ? 4 : 3;
			}

			return 1;
		}

		public static int BmpTestRaw(Context s)
		{
			var r = 0;
			var sz = 0;
			if (Get8(s) != 66)
				return 0;
			if (Get8(s) != 77)
				return 0;
			Get32le(s);
			Get16le(s);
			Get16le(s);
			Get32le(s);
			sz = (int)Get32le(s);
			r = sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124 ? 1 : 0;
			return r;
		}

		public static int BmpSetMaskDefaults(BmpData* info, int compress)
		{
			if (compress == 3)
				return 1;
			if (compress == 0)
			{
				if (info->bpp == 16)
				{
					info->mr = 31u << 10;
					info->mg = 31u << 5;
					info->mb = 31u << 0;
				}
				else if (info->bpp == 32)
				{
					info->mr = 0xffu << 16;
					info->mg = 0xffu << 8;
					info->mb = 0xffu << 0;
					info->ma = 0xffu << 24;
					info->all_a = 0;
				}
				else
				{
					info->mr = info->mg = info->mb = info->ma = 0;
				}

				return 1;
			}

			return 0;
		}

		public static void* BmpParseHeader(Context s, BmpData* info)
		{
			var hsz = 0;
			if (Get8(s) != 66 || Get8(s) != 77)
				return (byte*)(ulong)(Err("not BMP") != 0 ? 0 : 0);
			Get32le(s);
			Get16le(s);
			Get16le(s);
			info->offset = (int)Get32le(s);
			info->hsz = hsz = (int)Get32le(s);
			info->mr = info->mg = info->mb = info->ma = 0;
			info->extra_read = 14;
			if (info->offset < 0)
				return (byte*)(ulong)(Err("bad BMP") != 0 ? 0 : 0);
			if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124)
				return (byte*)(ulong)(Err("unknown BMP") != 0 ? 0 : 0);
			if (hsz == 12)
			{
				s.img_x = (uint)Get16le(s);
				s.img_y = (uint)Get16le(s);
			}
			else
			{
				s.img_x = Get32le(s);
				s.img_y = Get32le(s);
			}

			if (Get16le(s) != 1)
				return (byte*)(ulong)(Err("bad BMP") != 0 ? 0 : 0);
			info->bpp = Get16le(s);
			if (hsz != 12)
			{
				var compress = (int)Get32le(s);
				if (compress == 1 || compress == 2)
					return (byte*)(ulong)(Err("BMP RLE") != 0 ? 0 : 0);
				if (compress >= 4)
					return (byte*)(ulong)(Err("BMP JPEG/PNG") != 0 ? 0 : 0);
				if (compress == 3 && info->bpp != 16 && info->bpp != 32)
					return (byte*)(ulong)(Err("bad BMP") != 0 ? 0 : 0);
				Get32le(s);
				Get32le(s);
				Get32le(s);
				Get32le(s);
				Get32le(s);
				if (hsz == 40 || hsz == 56)
				{
					if (hsz == 56)
					{
						Get32le(s);
						Get32le(s);
						Get32le(s);
						Get32le(s);
					}

					if (info->bpp == 16 || info->bpp == 32)
					{
						if (compress == 0)
						{
							BmpSetMaskDefaults(info, compress);
						}
						else if (compress == 3)
						{
							info->mr = Get32le(s);
							info->mg = Get32le(s);
							info->mb = Get32le(s);
							info->extra_read += 12;
							if (info->mr == info->mg && info->mg == info->mb)
								return (byte*)(ulong)(Err("bad BMP") != 0 ? 0 : 0);
						}
						else
						{
							return (byte*)(ulong)(Err("bad BMP") != 0 ? 0 : 0);
						}
					}
				}
				else
				{
					var i = 0;
					if (hsz != 108 && hsz != 124)
						return (byte*)(ulong)(Err("bad BMP") != 0 ? 0 : 0);
					info->mr = Get32le(s);
					info->mg = Get32le(s);
					info->mb = Get32le(s);
					info->ma = Get32le(s);
					if (compress != 3)
						BmpSetMaskDefaults(info, compress);
					Get32le(s);
					for (i = 0; i < 12; ++i)
						Get32le(s);
					if (hsz == 124)
					{
						Get32le(s);
						Get32le(s);
						Get32le(s);
						Get32le(s);
					}
				}
			}

			return (void*)1;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct BmpData
		{
			public int bpp;
			public int offset;
			public int hsz;
			public uint mr;
			public uint mg;
			public uint mb;
			public uint ma;
			public uint all_a;
			public int extra_read;
		}
	}
}
