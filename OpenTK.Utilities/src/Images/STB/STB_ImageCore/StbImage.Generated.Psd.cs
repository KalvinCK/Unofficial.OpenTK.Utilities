// Generated by Sichem at 12/24/2021 8:28:15 PM

using Hebron.Runtime;

namespace OpenTK.Utilities.Images
{
	unsafe partial class ImageCore
	{
		public static int PsdTest(Context s)
		{
			var r = Get32be(s) == 0x38425053 ? 1 : 0;
			Rewind(s);
			return r;
		}

		public static void* PsdLoad(Context s, int* x, int* y, int* comp, int req_comp,
			ResultInfo* ri, int bpc)
		{
			var pixelCount = 0;
			var channelCount = 0;
			var compression = 0;
			var channel = 0;
			var i = 0;
			var bitdepth = 0;
			var w = 0;
			var h = 0;
			byte* _out_;
			if (Get32be(s) != 0x38425053)
				return (byte*)(ulong)(Err("not PSD") != 0 ? 0 : 0);
			if (Get16be(s) != 1)
				return (byte*)(ulong)(Err("wrong version") != 0 ? 0 : 0);
			Skip(s, 6);
			channelCount = Get16be(s);
			if (channelCount < 0 || channelCount > 16)
				return (byte*)(ulong)(Err("wrong channel count") != 0 ? 0 : 0);
			h = (int)Get32be(s);
			w = (int)Get32be(s);
			if (h > 1 << 24)
				return (byte*)(ulong)(Err("too large") != 0 ? 0 : 0);
			if (w > 1 << 24)
				return (byte*)(ulong)(Err("too large") != 0 ? 0 : 0);
			bitdepth = Get16be(s);
			if (bitdepth != 8 && bitdepth != 16)
				return (byte*)(ulong)(Err("unsupported bit depth") != 0 ? 0 : 0);
			if (Get16be(s) != 3)
				return (byte*)(ulong)(Err("wrong color format") != 0 ? 0 : 0);
			Skip(s, (int)Get32be(s));
			Skip(s, (int)Get32be(s));
			Skip(s, (int)Get32be(s));
			compression = Get16be(s);
			if (compression > 1)
				return (byte*)(ulong)(Err("bad compression") != 0 ? 0 : 0);
			if (Mad3sizesValid(4, w, h, 0) == 0)
				return (byte*)(ulong)(Err("too large") != 0 ? 0 : 0);
			if (compression == 0 && bitdepth == 16 && bpc == 16)
			{
				_out_ = (byte*)MallocMad3(8, w, h, 0);
				ri->bits_per_channel = 16;
			}
			else
			{
				_out_ = (byte*)Malloc((ulong)(4 * w * h));
			}

			if (_out_ == null)
				return (byte*)(ulong)(Err("outofmem") != 0 ? 0 : 0);
			pixelCount = w * h;
			if (compression != 0)
			{
				Skip(s, h * channelCount * 2);
				for (channel = 0; channel < 4; channel++)
				{
					byte* p;
					p = _out_ + channel;
					if (channel >= channelCount)
					{
						for (i = 0; i < pixelCount; i++, p += 4)
							*p = (byte)(channel == 3 ? 255 : 0);
					}
					else
					{
						if (PsdDecodeRle(s, p, pixelCount) == 0)
						{
							CRuntime.free(_out_);
							return (byte*)(ulong)(Err("corrupt") != 0 ? 0 : 0);
						}
					}
				}
			}
			else
			{
				for (channel = 0; channel < 4; channel++)
					if (channel >= channelCount)
					{
						if (bitdepth == 16 && bpc == 16)
						{
							var q = (ushort*)_out_ + channel;
							var val = (ushort)(channel == 3 ? 65535 : 0);
							for (i = 0; i < pixelCount; i++, q += 4)
								*q = val;
						}
						else
						{
							var p = _out_ + channel;
							var val = (byte)(channel == 3 ? 255 : 0);
							for (i = 0; i < pixelCount; i++, p += 4)
								*p = val;
						}
					}
					else
					{
						if (ri->bits_per_channel == 16)
						{
							var q = (ushort*)_out_ + channel;
							for (i = 0; i < pixelCount; i++, q += 4)
								*q = (ushort)Get16be(s);
						}
						else
						{
							var p = _out_ + channel;
							if (bitdepth == 16)
								for (i = 0; i < pixelCount; i++, p += 4)
									*p = (byte)(Get16be(s) >> 8);
							else
								for (i = 0; i < pixelCount; i++, p += 4)
									*p = Get8(s);
						}
					}
			}

			if (channelCount >= 4)
			{
				if (ri->bits_per_channel == 16)
					for (i = 0; i < w * h; ++i)
					{
						var pixel = (ushort*)_out_ + 4 * i;
						if (pixel[3] != 0 && pixel[3] != 65535)
						{
							var a = pixel[3] / 65535.0f;
							var ra = 1.0f / a;
							var inv_a = 65535.0f * (1 - ra);
							pixel[0] = (ushort)(pixel[0] * ra + inv_a);
							pixel[1] = (ushort)(pixel[1] * ra + inv_a);
							pixel[2] = (ushort)(pixel[2] * ra + inv_a);
						}
					}
				else
					for (i = 0; i < w * h; ++i)
					{
						var pixel = _out_ + 4 * i;
						if (pixel[3] != 0 && pixel[3] != 255)
						{
							var a = pixel[3] / 255.0f;
							var ra = 1.0f / a;
							var inv_a = 255.0f * (1 - ra);
							pixel[0] = (byte)(pixel[0] * ra + inv_a);
							pixel[1] = (byte)(pixel[1] * ra + inv_a);
							pixel[2] = (byte)(pixel[2] * ra + inv_a);
						}
					}
			}

			if (req_comp != 0 && req_comp != 4)
			{
				if (ri->bits_per_channel == 16)
					_out_ = (byte*)ConvertFormat16((ushort*)_out_, 4, req_comp, (uint)w, (uint)h);
				else
					_out_ = ConvertFormat(_out_, 4, req_comp, (uint)w, (uint)h);
				if (_out_ == null)
					return _out_;
			}

			if (comp != null)
				*comp = 4;
			*y = h;
			*x = w;
			return _out_;
		}

		public static int PsdInfo(Context s, int* x, int* y, int* comp)
		{
			var channelCount = 0;
			var dummy = 0;
			var depth = 0;
			if (x == null)
				x = &dummy;
			if (y == null)
				y = &dummy;
			if (comp == null)
				comp = &dummy;
			if (Get32be(s) != 0x38425053)
			{
				Rewind(s);
				return 0;
			}

			if (Get16be(s) != 1)
			{
				Rewind(s);
				return 0;
			}

			Skip(s, 6);
			channelCount = Get16be(s);
			if (channelCount < 0 || channelCount > 16)
			{
				Rewind(s);
				return 0;
			}

			*y = (int)Get32be(s);
			*x = (int)Get32be(s);
			depth = Get16be(s);
			if (depth != 8 && depth != 16)
			{
				Rewind(s);
				return 0;
			}

			if (Get16be(s) != 3)
			{
				Rewind(s);
				return 0;
			}

			*comp = 4;
			return 1;
		}

		public static int PsdIs16(Context s)
		{
			var channelCount = 0;
			var depth = 0;
			if (Get32be(s) != 0x38425053)
			{
				Rewind(s);
				return 0;
			}

			if (Get16be(s) != 1)
			{
				Rewind(s);
				return 0;
			}

			Skip(s, 6);
			channelCount = Get16be(s);
			if (channelCount < 0 || channelCount > 16)
			{
				Rewind(s);
				return 0;
			}

			depth = Get16be(s);
			if (depth != 16)
			{
				Rewind(s);
				return 0;
			}

			return 1;
		}

		public static int PsdDecodeRle(Context s, byte* p, int pixelCount)
		{
			var count = 0;
			var nleft = 0;
			var len = 0;
			count = 0;
			while ((nleft = pixelCount - count) > 0)
			{
				len = Get8(s);
				if (len == 128)
				{
				}
				else if (len < 128)
				{
					len++;
					if (len > nleft)
						return 0;
					count += len;
					while (len != 0)
					{
						*p = Get8(s);
						p += 4;
						len--;
					}
				}
				else if (len > 128)
				{
					byte val = 0;
					len = 257 - len;
					if (len > nleft)
						return 0;
					val = Get8(s);
					count += len;
					while (len != 0)
					{
						*p = val;
						p += 4;
						len--;
					}
				}
			}

			return 1;
		}
	}
}
